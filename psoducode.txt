FUNCTION main(argc, argv, envp)
    IF argc != 5 THEN
        PRINT "Usage: ./pipex file1 cmd1 cmd2 file2"
        EXIT FAILURE
    ENDIF

    // Parse PATH environment variable
    paths = take_path(envp)  

    // Open input (file1) and output (file2) files
    input_fd = open(argv[1], O_RDONLY)
    IF input_fd < 0 THEN
        PRINT "Error opening file1"
        EXIT FAILURE
    ENDIF

    output_fd = open(argv[4], O_WRONLY | O_CREAT | O_TRUNC, 0644)
    IF output_fd < 0 THEN
        PRINT "Error opening file2"
        EXIT FAILURE
    ENDIF

    // Create pipe
    pipe_fd = pipe()
    IF pipe_fd < 0 THEN
        PRINT "Error creating pipe"
        EXIT FAILURE
    ENDIF

    // Fork and execute first command
    pid1 = fork()
    IF pid1 == 0 THEN
        close(pipe_fd[0])            // Close read end
        dup2(input_fd, STDIN_FILENO) // Redirect input
        dup2(pipe_fd[1], STDOUT_FILENO) // Redirect output to pipe
        close(pipe_fd[1])

        cmd1_path = pick_command_path(paths, argv[2]) // Find cmd1 in PATH
        EXECVE(cmd1_path, split_command(argv[2]), envp) // Execute cmd1
        PRINT "Error executing cmd1"
        EXIT FAILURE
    ENDIF

    // Fork and execute second command
    pid2 = fork()
    IF pid2 == 0 THEN
        close(pipe_fd[1])            // Close write end
        dup2(pipe_fd[0], STDIN_FILENO) // Redirect input from pipe
        dup2(output_fd, STDOUT_FILENO) // Redirect output to file
        close(pipe_fd[0])

        cmd2_path = pick_command_path(paths, argv[3]) // Find cmd2 in PATH
        EXECVE(cmd2_path, split_command(argv[3]), envp) // Execute cmd2
        PRINT "Error executing cmd2"
        EXIT FAILURE
    ENDIF

    // Parent Process: Close all and wait
    close(pipe_fd[0])
    close(pipe_fd[1])
    close(input_fd)
    close(output_fd)
    WAIT for pid1
    WAIT for pid2

    RETURN 0
END FUNCTION









#include "pipex.h"

char	**takepaths(char **env)
{
    char	*pathstr;
    char	**back;
    int		enc;

    if (!env)
        exit(EXIT_FAILURE);
    enc = 0;
    while (env[enc])
    {
        if (ft_strncmp("PATH=", env[enc], 5) == 0)
            break ;
        enc++;
    }
    if (!env[enc])
        return (NULL);
    pathstr = env[enc] + 5;
    enc = 0;
    back = ft_split(pathstr, ':');
    while (back[enc])
    {
        back[enc] = ft_strjoin(back[enc], "/");
        enc++;
    }
    return (back);
}

char	*pick(char **path, char* cmd)
{
    int		pass;
    char	*realpath;

    pass = 0;

    while (path[pass])
    {
        realpath = ft_strjoin(path[pass], cmd);
        if (access(realpath, X_OK) == 0)
            return (realpath);
        free(realpath);
        pass++;
    }
    return (NULL);
}

void	firstcmd(char **av, char **paths, int *pipfd)
{
    char	**cmd;
    char	*path;
    int	infile;

    infile = open(av[1], O_RDONLY);
    if (infile < 0)
        return ;
    if (dup2(infile, STDIN_FILENO) == -1 || dup2(pipfd[1], STDOUT_FILENO) == -1)
        return ;
    cmd = ft_split(av[2], ' ');
    path = pick(paths, cmd[0]);
    close(infile);
    if (!path)
        return ;
    execve(path, cmd, NULL);
    return ;
}

int main(int ac, char **av, char **ev)
{
    int		pipfd[2];
    pid_t	pid;
    char	**paths;
    char	*path;
    int		infile;
    int		outfile;

    if (pipe(pipfd) == -1)
        return (0);
    paths = takepaths(ev);
    pid = fork();
    if (pid == -1)
        return (write(2, "fork failed\n", 13), 0);
    if (pid == 0)
        firstcmd(av, paths, pipfd); // No need for infile here
    else 
    {
        infile = open(av[1], O_RDONLY);
        if (infile < 0)
            return (write(1, "open infile failed\n", 19), 0);

        outfile = open(av[4], O_APPEND | O_CREAT | O_RDWR, 0644);
        if (outfile == -1)
            return (write(1, "open outfile failed\n", 20), 0);

        if (dup2(pipfd[0], STDIN_FILENO) == -1 || dup2(outfile, STDOUT_FILENO) == -1)
            return (0);

        close(pipfd[1]);
        char **cmd = ft_split(av[3], ' ');
        path = pick(paths, cmd[0]);
        if (!path)
            return (write(1, "command not found\n", 18), 0);

        wait(NULL); // Wait for the first command to finish
        execve(path, cmd, NULL);
    }
    return (0);
}
